using Descope.Mgmt;
using Descope.Auth;

namespace Descope;

/// <summary>
/// Wrapper implementation of the Descope Client that delegates to the generated clients.
/// This class will NOT be regenerated by Kiota and provides a stable interface for dependency injection.
/// </summary>
public class DescopeClient : IDescopeClient
{
    private readonly DescopeMgmtClient _mgmtClient;
    private readonly DescopeAuthClient _authClient;

    /// <summary>
    /// Initializes a new instance of the DescopeClient wrapper.
    /// </summary>
    /// <param name="mgmtKiotaClient">The generated Management Kiota client to wrap.</param>
    /// <param name="authKiotaClient">The generated Auth Kiota client to wrap.</param>
    /// <param name="projectId">The Descope project ID.</param>
    /// <param name="baseUrl">The base URL for the Descope API.</param>
    /// <param name="fetchKeysHttpClient">An HttpClient to fetch public keys, needed for JWT validation.</param>
    internal DescopeClient(
        DescopeMgmtKiotaClient mgmtKiotaClient,
        DescopeAuthKiotaClient authKiotaClient,
        string projectId,
        string baseUrl,
        HttpClient fetchKeysHttpClient)
    {
        _mgmtClient = new DescopeMgmtClient(mgmtKiotaClient);
        _authClient = new DescopeAuthClient(authKiotaClient, projectId, baseUrl, fetchKeysHttpClient);
    }

    public class DescopeMgmtClient
    {
        private readonly DescopeMgmtKiotaClient _mgmtKiotaClient;

        internal DescopeMgmtClient(DescopeMgmtKiotaClient mgmtKiotaClient)
        {
            _mgmtKiotaClient = mgmtKiotaClient;
        }

        public Mgmt.V1.Mgmt.MgmtRequestBuilder V1 => _mgmtKiotaClient.V1.Mgmt;
        public Mgmt.V2.Mgmt.MgmtRequestBuilder V2 => _mgmtKiotaClient.V2.Mgmt;
    }

    // Auth client wrapper, exposes kiota client and token actions that include local JWT validation and additional logic
    public class DescopeAuthClient : ITokenActions
    {
        private readonly DescopeAuthKiotaClient _authKiotaClient;
        private readonly TokenActions _tokenActions;

        internal DescopeAuthClient(
            DescopeAuthKiotaClient authKiotaClient,
            string projectId,
            string baseUrl,
            HttpClient fetchKeysHttpClient)
        {
            _authKiotaClient = authKiotaClient;
            var jwtValidator = new JwtValidator(projectId, baseUrl, fetchKeysHttpClient);
            _tokenActions = new TokenActions(jwtValidator, authKiotaClient.V1.Auth);
        }

        public Auth.V1.Auth.AuthRequestBuilder V1 => _authKiotaClient.V1.Auth;

        // Forward ITokenActions methods to TokenActions implementation

        /// <inheritdoc/>
        public async Task<Token> ValidateSessionAsync(string sessionJwt) => await _tokenActions.ValidateSessionAsync(sessionJwt);

        /// <inheritdoc/>
        public async Task<Token> RefreshSessionAsync(string refreshJwt) => await _tokenActions.RefreshSessionAsync(refreshJwt);

        /// <inheritdoc/>
        public async Task<Token> ValidateAndRefreshSession(string sessionJwt, string refreshJwt) =>
            await _tokenActions.ValidateAndRefreshSession(sessionJwt, refreshJwt);

        /// <inheritdoc/>
        public async Task<Token> ExchangeAccessKey(string accessKey, Auth.Models.Onetimev1.AccessKeyLoginOptions? loginOptions = null) =>
            await _tokenActions.ExchangeAccessKey(accessKey, loginOptions);

    }

    /// <inheritdoc/>
    public DescopeMgmtClient Mgmt => _mgmtClient;

    /// <inheritdoc/>
    public DescopeAuthClient Auth => _authClient;
}
